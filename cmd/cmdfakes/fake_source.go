// Code generated by counterfeiter. DO NOT EDIT.
package cmdfakes

import (
	"math/rand"
	"sync"
)

type FakeSource struct {
	Int63Stub        func() int64
	int63Mutex       sync.RWMutex
	int63ArgsForCall []struct{}
	int63Returns     struct {
		result1 int64
	}
	int63ReturnsOnCall map[int]struct {
		result1 int64
	}
	SeedStub        func(seed int64)
	seedMutex       sync.RWMutex
	seedArgsForCall []struct {
		seed int64
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSource) Int63() int64 {
	fake.int63Mutex.Lock()
	ret, specificReturn := fake.int63ReturnsOnCall[len(fake.int63ArgsForCall)]
	fake.int63ArgsForCall = append(fake.int63ArgsForCall, struct{}{})
	fake.recordInvocation("Int63", []interface{}{})
	fake.int63Mutex.Unlock()
	if fake.Int63Stub != nil {
		return fake.Int63Stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.int63Returns.result1
}

func (fake *FakeSource) Int63CallCount() int {
	fake.int63Mutex.RLock()
	defer fake.int63Mutex.RUnlock()
	return len(fake.int63ArgsForCall)
}

func (fake *FakeSource) Int63Returns(result1 int64) {
	fake.Int63Stub = nil
	fake.int63Returns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeSource) Int63ReturnsOnCall(i int, result1 int64) {
	fake.Int63Stub = nil
	if fake.int63ReturnsOnCall == nil {
		fake.int63ReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.int63ReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeSource) Seed(seed int64) {
	fake.seedMutex.Lock()
	fake.seedArgsForCall = append(fake.seedArgsForCall, struct {
		seed int64
	}{seed})
	fake.recordInvocation("Seed", []interface{}{seed})
	fake.seedMutex.Unlock()
	if fake.SeedStub != nil {
		fake.SeedStub(seed)
	}
}

func (fake *FakeSource) SeedCallCount() int {
	fake.seedMutex.RLock()
	defer fake.seedMutex.RUnlock()
	return len(fake.seedArgsForCall)
}

func (fake *FakeSource) SeedArgsForCall(i int) int64 {
	fake.seedMutex.RLock()
	defer fake.seedMutex.RUnlock()
	return fake.seedArgsForCall[i].seed
}

func (fake *FakeSource) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.int63Mutex.RLock()
	defer fake.int63Mutex.RUnlock()
	fake.seedMutex.RLock()
	defer fake.seedMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSource) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ rand.Source = new(FakeSource)
